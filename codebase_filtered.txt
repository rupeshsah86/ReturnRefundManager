=== Directory Structure ===
└── return-refund-manager
    ├── .mvn
    │   └── wrapper
    │       └── maven-wrapper.properties
    ├── HELP.md
    ├── codebase_filtered.py
    ├── mvnw
    ├── mvnw.cmd
    ├── pom.xml
    ├── src
    │   ├── main
    │   │   ├── java
    │   │   │   └── com
    │   │   │       └── ecommerce
    │   │   │           └── returnmanager
    │   │   │               ├── ReturnRefundManagerApplication.java
    │   │   │               ├── TestDataInitializer.java
    │   │   │               ├── config
    │   │   │               │   ├── AuditLogger.java
    │   │   │               │   ├── CustomAuthSuccessHandler.java
    │   │   │               │   ├── OpenApiConfig.java
    │   │   │               │   ├── RateLimitConfig.java
    │   │   │               │   ├── RateLimitInterceptor.java
    │   │   │               │   └── SecurityConfig.java
    │   │   │               ├── controller
    │   │   │               │   ├── AdminReturnController.java
    │   │   │               │   ├── CustomerReturnController.java
    │   │   │               │   ├── DashboardController.java
    │   │   │               │   ├── LoginController.java
    │   │   │               │   └── WebController.java
    │   │   │               ├── dto
    │   │   │               │   ├── ApiResponse.java
    │   │   │               │   └── ErrorResponse.java
    │   │   │               ├── exception
    │   │   │               │   └── GlobalExceptionHandler.java
    │   │   │               ├── model
    │   │   │               │   ├── Order.java
    │   │   │               │   ├── OrderItem.java
    │   │   │               │   ├── ReturnRequest.java
    │   │   │               │   └── User.java
    │   │   │               ├── repository
    │   │   │               │   ├── OrderItemRepository.java
    │   │   │               │   ├── OrderRepository.java
    │   │   │               │   ├── ReturnRequestRepository.java
    │   │   │               │   └── UserRepository.java
    │   │   │               └── service
    │   │   │                   ├── EmailService.java
    │   │   │                   ├── ReturnRequestService.java
    │   │   │                   └── impl
    │   │   │                       ├── ReturnRequestServiceImpl.java
    │   │   │                       └── UserDetailsServiceImpl.java
    │   │   └── resources
    │   │       ├── application.properties
    │   │       └── templates
    │   │           ├── admin-dashboard.html
    │   │           ├── login.html
    │   │           ├── return-form.html
    │   │           └── return-success.html
    │   └── test
    │       ├── java
    │       │   └── com
    │       │       └── ecommerce
    │       │           └── returnmanager
    │       │               ├── ReturnRefundManagerApplicationTests.java
    │       │               ├── config
    │       │               │   └── SecurityConfigTest.java
    │       │               ├── controller
    │       │               │   ├── AdminReturnControllerSecurityTest.java
    │       │               │   └── CustomerReturnControllerTest.java
    │       │               └── service
    │       │                   ├── ReturnRequestServiceIntegrationTest.java
    │       │                   └── ReturnRequestServiceTest.java
    │       └── resources
    │           └── application.properties

=== File Contents ===

--- File: mvnw.cmd ---

<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.4
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" ("%__MVNW_CMD__%" %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND -eq $False) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace "^.*$MVNW_REPO_PATTERN",'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''

$MAVEN_M2_PATH = "$HOME/.m2"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_M2_PATH = "$env:MAVEN_USER_HOME"
}

if (-not (Test-Path -Path $MAVEN_M2_PATH)) {
    New-Item -Path $MAVEN_M2_PATH -ItemType Directory | Out-Null
}

$MAVEN_WRAPPER_DISTS = $null
if ((Get-Item $MAVEN_M2_PATH).Target[0] -eq $null) {
  $MAVEN_WRAPPER_DISTS = "$MAVEN_M2_PATH/wrapper/dists"
} else {
  $MAVEN_WRAPPER_DISTS = (Get-Item $MAVEN_M2_PATH).Target[0] + "/wrapper/dists"
}

$MAVEN_HOME_PARENT = "$MAVEN_WRAPPER_DISTS/$distributionUrlNameMain"
$MAVEN_HOME_NAME = ([System.Security.Cryptography.SHA256]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null

# Find the actual extracted directory name (handles snapshots where filename != directory name)
$actualDistributionDir = ""

# First try the expected directory name (for regular distributions)
$expectedPath = Join-Path "$TMP_DOWNLOAD_DIR" "$distributionUrlNameMain"
$expectedMvnPath = Join-Path "$expectedPath" "bin/$MVN_CMD"
if ((Test-Path -Path $expectedPath -PathType Container) -and (Test-Path -Path $expectedMvnPath -PathType Leaf)) {
  $actualDistributionDir = $distributionUrlNameMain
}

# If not found, search for any directory with the Maven executable (for snapshots)
if (!$actualDistributionDir) {
  Get-ChildItem -Path "$TMP_DOWNLOAD_DIR" -Directory | ForEach-Object {
    $testPath = Join-Path $_.FullName "bin/$MVN_CMD"
    if (Test-Path -Path $testPath -PathType Leaf) {
      $actualDistributionDir = $_.Name
    }
  }
}

if (!$actualDistributionDir) {
  Write-Error "Could not find Maven distribution directory in extracted archive"
}

Write-Verbose "Found extracted Maven distribution directory: $actualDistributionDir"
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$actualDistributionDir" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"


--- File: pom.xml ---

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.6</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.ecommerce</groupId>
    <artifactId>return-refund-manager</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>return-refund-manager</name>
    <description>Return and Refund Management System</description>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <!-- Core Spring Boot dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Spring Security -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <!-- Test dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Add these dependencies in the <dependencies> section -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.8.6</version>
        </dependency>
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-common</artifactId>
            <version>2.8.6</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <!-- Compiler plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>

            <!-- Spring Boot Maven plugin -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>


--- File: HELP.md ---

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.6/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.6/maven-plugin/build-image.html)
* [Spring Web](https://docs.spring.io/spring-boot/3.5.6/reference/web/servlet.html)
* [Spring Data JPA](https://docs.spring.io/spring-boot/3.5.6/reference/data/sql.html#data.sql.jpa-and-spring-data)
* [Validation](https://docs.spring.io/spring-boot/3.5.6/reference/io/validation.html)

### Guides
The following guides illustrate how to use some features concretely:

* [Building a RESTful Web Service](https://spring.io/guides/gs/rest-service/)
* [Serving Web Content with Spring MVC](https://spring.io/guides/gs/serving-web-content/)
* [Building REST services with Spring](https://spring.io/guides/tutorials/rest/)
* [Accessing Data with JPA](https://spring.io/guides/gs/accessing-data-jpa/)
* [Validation](https://spring.io/guides/gs/validating-form-input/)
* [Accessing data with MySQL](https://spring.io/guides/gs/accessing-data-mysql/)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.



--- File: codebase_filtered.py ---

import os
import sys

def generate_tree(root_dir, output_file, prefix="", is_last=True):
    """Generate a tree-like string representation, skipping dot files, specific directories, and output file."""
    tree = []
    root_name = os.path.basename(root_dir)
    tree.append(f"{prefix}{'└── ' if is_last else '├── '}{root_name}")
    
    prefix += "    " if is_last else "│   "
    skip_dirs = {'.git', 'node_modules', 'venv', '__pycache__', '.venv', 'dist', 'build', '.idea', 'target'}
    
    try:
        output_abs_path = os.path.abspath(output_file)
        items = sorted(os.listdir(root_dir))
        for i, item in enumerate(items):
            item_path = os.path.join(root_dir, item)
            is_last_item = i == len(items) - 1
            if os.path.abspath(item_path) == output_abs_path:
                continue
            if os.path.isdir(item_path):
                if item in skip_dirs:
                    continue
                tree.extend(generate_tree(item_path, output_file, prefix, is_last_item))
            elif not item.startswith('.'):
                tree.append(f"{prefix}{'└── ' if is_last_item else '├── '}{item}")
    except PermissionError:
        tree.append(f"{prefix}{'└── ' if is_last_item else '├── '}[Permission denied]")
    
    return tree

def collect_codebase_filtered(root_dir, output_file):
    skip_dirs = {'.git', 'node_modules', 'venv', '__pycache__', '.venv', 'dist', 'build', '.idea', 'target'}
    output_abs_path = os.path.abspath(output_file)
    
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Write directory tree
        outfile.write("=== Directory Structure ===\n")
        tree = generate_tree(root_dir, output_file)
        outfile.write("\n".join(tree))
        outfile.write("\n\n=== File Contents ===\n\n")
        
        # Collect file contents
        for dirpath, dirnames, filenames in os.walk(root_dir, topdown=True):
            dirnames[:] = [d for d in dirnames if d not in skip_dirs]
            
            for filename in filenames:
                if filename.startswith('.'):
                    continue
                file_path = os.path.join(dirpath, filename)
                if os.path.abspath(file_path) == output_abs_path:
                    continue
                relative_path = os.path.relpath(file_path, root_dir)
                
                outfile.write(f"--- File: {relative_path} ---\n\n")
                
                try:
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                        outfile.write(content)
                        outfile.write("\n\n")
                except UnicodeDecodeError:
                    outfile.write("[[Binary file or encoding error - content skipped]]\n\n")
                except Exception as e:
                    outfile.write(f"[[Error reading file: {e}]]\n\n")

    print(f"Codebase collected into {output_file}")

if __name__ == "__main__":
    root_dir = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()
    output_file = sys.argv[2] if len(sys.argv) > 2 else "codebase_filtered.txt"
    collect_codebase_filtered(root_dir, output_file)

--- File: mvnw ---

#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.4
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

scriptDir="$(dirname "$0")"
scriptName="$(basename "$0")"

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"$scriptDir/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${scriptName#mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c - >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi

# Find the actual extracted directory name (handles snapshots where filename != directory name)
actualDistributionDir=""

# First try the expected directory name (for regular distributions)
if [ -d "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" ]; then
  if [ -f "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/bin/$MVN_CMD" ]; then
    actualDistributionDir="$distributionUrlNameMain"
  fi
fi

# If not found, search for any directory with the Maven executable (for snapshots)
if [ -z "$actualDistributionDir" ]; then
  # enable globbing to iterate over items
  set +f
  for dir in "$TMP_DOWNLOAD_DIR"/*; do
    if [ -d "$dir" ]; then
      if [ -f "$dir/bin/$MVN_CMD" ]; then
        actualDistributionDir="$(basename "$dir")"
        break
      fi
    fi
  done
  set -f
fi

if [ -z "$actualDistributionDir" ]; then
  verbose "Contents of $TMP_DOWNLOAD_DIR:"
  verbose "$(ls -la "$TMP_DOWNLOAD_DIR")"
  die "Could not find Maven distribution directory in extracted archive"
fi

verbose "Found extracted Maven distribution directory: $actualDistributionDir"
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$actualDistributionDir/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$actualDistributionDir" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"


--- File: .mvn/wrapper/maven-wrapper.properties ---

wrapperVersion=3.3.4
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.11/apache-maven-3.9.11-bin.zip


--- File: src/test/resources/application.properties ---

# # Test Database Configuration
# spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
# spring.datasource.driver-class-name=org.h2.Driver
# spring.datasource.username=rupesh
# spring.datasource.password=Rupeshsah@5920

# # JPA Configuration for Tests
# spring.jpa.hibernate.ddl-auto=create-drop
# spring.jpa.show-sql=false
# spring.jpa.properties.hibernate.format_sql=false
# spring.jpa.defer-datasource-initialization=true

# # Disable security for some tests
# spring.security.user.name=test
# spring.security.user.password=test

# # Disable initialization for tests
# spring.sql.init.mode=never

--- File: src/test/java/com/ecommerce/returnmanager/ReturnRefundManagerApplicationTests.java ---

package com.ecommerce.returnmanager;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

@SpringBootTest
@ActiveProfiles("test")
class ReturnRefundManagerApplicationTests {

    @Test
    void contextLoads() {
        // Test that the application context loads successfully
    }
}
//     @Test
//     void applicationStarts() {
//         // Basic test to verify application starts
//         ReturnRefundManagerApplication.main(new String[] {});
//     }
// }

--- File: src/test/java/com/ecommerce/returnmanager/config/SecurityConfigTest.java ---

// package com.ecommerce.returnmanager.config;

// import org.junit.jupiter.api.Test;
// import org.springframework.beans.factory.annotation.Autowired;
// import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
// import org.springframework.boot.test.context.SpringBootTest;
// import org.springframework.security.test.context.support.WithMockUser;
// import org.springframework.test.web.servlet.MockMvc;
// import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
// import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

// @SpringBootTest
// @AutoConfigureMockMvc
// public class SecurityConfigTest {

//     @Autowired
//     private MockMvc mockMvc;

//     @Test
//     public void publicEndpoints_ShouldBeAccessible() throws Exception {
//         mockMvc.perform(get("/"))
//                .andExpect(status().isOk());

//         mockMvc.perform(get("/login"))
//                .andExpect(status().isOk());
//     }

//     @Test
//     @WithMockUser(roles = "CUSTOMER")
//     public void customerApiEndpoints_WithCustomerRole_ShouldBeAccessible() throws Exception {
//         mockMvc.perform(get("/api/v1/customer/returns/1"))
//                .andExpect(status().isOk());
//     }

//     @Test
//     @WithMockUser(roles = "ADMIN")
//     public void adminEndpoints_WithAdminRole_ShouldBeAccessible() throws Exception {
//         mockMvc.perform(get("/admin/dashboard"))
//                .andExpect(status().isOk());
//     }
// }

--- File: src/test/java/com/ecommerce/returnmanager/controller/AdminReturnControllerSecurityTest.java ---

// package com.ecommerce.returnmanager.controller;
// import org.junit.jupiter.api.Test;
// import org.springframework.beans.factory.annotation.Autowired;
// import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
// import org.springframework.boot.test.mock.mockito.MockBean;
// import org.springframework.security.test.context.support.WithMockUser;
// import org.springframework.test.web.servlet.MockMvc;
// import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
// import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
// import static org.mockito.Mockito.when;
// import java.util.Collections;

// // Import your actual service and controller classes
// import com.ecommerce.returnmanager.controller.AdminReturnController;
// import com.ecommerce.returnmanager.service.ReturnRequestService;

// @WebMvcTest(AdminReturnController.class)
// class AdminReturnControllerSecurityTest {
    
//     @Autowired
//     private MockMvc mockMvc;
    
//     @MockBean
//     private ReturnRequestService returnRequestService;
    
//     @Test
//     @WithMockUser(roles = "ADMIN")
//     void getAllPendingReturns_WithAdminRole_ShouldReturnOk() throws Exception {
//         when(returnRequestService.getAllPendingRequests()).thenReturn(Collections.emptyList());
        
//         mockMvc.perform(get("/api/v1/admin/returns/pending"))
//                .andExpect(status().isOk());
//     }
    
//     @Test
//     @WithMockUser(roles = "CUSTOMER")
//     void getAllPendingReturns_WithCustomerRole_ShouldReturnForbidden() throws Exception {
//         mockMvc.perform(get("/api/v1/admin/returns/pending"))
//                .andExpect(status().isForbidden());
//     }
    
//     @Test
//     void getAllPendingReturns_WithoutAuthentication_ShouldReturnUnauthorized() throws Exception {
//         mockMvc.perform(get("/api/v1/admin/returns/pending"))
//                .andExpect(status().isUnauthorized());
//     }
// }

--- File: src/test/java/com/ecommerce/returnmanager/controller/CustomerReturnControllerTest.java ---

// package com.ecommerce.returnmanager.controller;

// import com.ecommerce.returnmanager.model.ReturnRequest;
// import com.ecommerce.returnmanager.model.User;
// import com.ecommerce.returnmanager.service.ReturnRequestService;
// import com.ecommerce.returnmanager.repository.UserRepository;
// import com.ecommerce.returnmanager.repository.ReturnRequestRepository; // Add this import
// import com.fasterxml.jackson.databind.ObjectMapper;
// import org.junit.jupiter.api.Test;
// import org.springframework.beans.factory.annotation.Autowired;
// import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
// import org.springframework.boot.test.mock.mockito.MockBean;
// import org.springframework.http.MediaType;
// import org.springframework.security.test.context.support.WithMockUser;
// import org.springframework.test.web.servlet.MockMvc;

// import java.util.Optional;

// import static org.mockito.ArgumentMatchers.any;
// import static org.mockito.Mockito.when;
// import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
// import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
// import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

// @WebMvcTest(CustomerReturnController.class)
// class CustomerReturnControllerTest {

//     @Autowired
//     private MockMvc mockMvc;

//     @MockBean
//     private ReturnRequestService returnRequestService;

//     @MockBean
//     private UserRepository userRepository;

//     @MockBean
//     private ReturnRequestRepository returnRequestRepository; // ADD THIS LINE

//     @Autowired
//     private ObjectMapper objectMapper;

//     @Test
//     @WithMockUser(username = "customer@test.com", roles = "CUSTOMER")
//     void getReturnDetails_WithValidId_ShouldReturnRequest() throws Exception {
//         User testUser = new User(1L, "Test Customer", "customer@test.com", "password", User.Role.CUSTOMER);
//         ReturnRequest returnRequest = new ReturnRequest();
//         returnRequest.setId(1L);
//         returnRequest.setStatus(ReturnRequest.ReturnStatus.PENDING);
//         returnRequest.setUser(testUser);

//         when(returnRequestService.getRequestById(1L)).thenReturn(Optional.of(returnRequest));
//         when(userRepository.findByEmail("customer@test.com")).thenReturn(Optional.of(testUser));

//         mockMvc.perform(get("/api/v1/customer/returns/1"))
//                 .andExpect(status().isOk())
//                 .andExpect(jsonPath("$.success").value(true))
//                 .andExpect(jsonPath("$.data.id").value(1L))
//                 .andExpect(jsonPath("$.data.status").value("PENDING"));
//     }

//     @Test
//     @WithMockUser(username = "customer@test.com", roles = "CUSTOMER")
//     void getReturnDetails_WithInvalidId_ShouldReturnNotFound() throws Exception {
//         when(returnRequestService.getRequestById(999L)).thenReturn(Optional.empty());
//         when(userRepository.findByEmail("customer@test.com")).thenReturn(Optional.of(new User()));

//         mockMvc.perform(get("/api/v1/customer/returns/999"))
//                 .andExpect(status().isNotFound())
//                 .andExpect(jsonPath("$.success").value(false));
//     }

//     @Test
//     @WithMockUser(username = "customer@test.com", roles = "CUSTOMER")
//     void initiateReturn_WithValidRequest_ShouldCreateReturn() throws Exception {
//         User testUser = new User(1L, "Test Customer", "customer@test.com", "password", User.Role.CUSTOMER);
//         ReturnRequest returnRequest = new ReturnRequest();
//         returnRequest.setId(1L);
//         returnRequest.setStatus(ReturnRequest.ReturnStatus.PENDING);
//         returnRequest.setUser(testUser);

//         when(returnRequestService.initiateReturn(any(ReturnRequest.class))).thenReturn(returnRequest);
//         when(userRepository.findByEmail("customer@test.com")).thenReturn(Optional.of(testUser));

//         mockMvc.perform(post("/api/v1/customer/returns")
//                 .with(csrf())
//                 .contentType(MediaType.APPLICATION_JSON)
//                 .content(objectMapper.writeValueAsString(returnRequest)))
//                 .andExpect(status().isCreated())
//                 .andExpect(jsonPath("$.success").value(true))
//                 .andExpect(jsonPath("$.data.id").value(1L));
//     }
// }

--- File: src/test/java/com/ecommerce/returnmanager/service/ReturnRequestServiceTest.java ---

// package com.ecommerce.returnmanager.service;

// import java.math.BigDecimal;
// import java.time.LocalDateTime;
// import java.util.Arrays;
// import java.util.List;
// import java.util.Optional;

// import static org.junit.jupiter.api.Assertions.assertEquals;
// import static org.junit.jupiter.api.Assertions.assertFalse;
// import static org.junit.jupiter.api.Assertions.assertNotNull;
// import org.junit.jupiter.api.BeforeEach;
// import org.junit.jupiter.api.Test;
// import org.junit.jupiter.api.extension.ExtendWith;
// import static org.mockito.ArgumentMatchers.any;
// import org.mockito.InjectMocks;
// import org.mockito.Mock;
// import static org.mockito.Mockito.times;
// import static org.mockito.Mockito.verify;
// import static org.mockito.Mockito.when;
// import org.mockito.junit.jupiter.MockitoExtension;

// import com.ecommerce.returnmanager.config.AuditLogger;  // Add this import
// import com.ecommerce.returnmanager.model.Order;
// import com.ecommerce.returnmanager.model.OrderItem;
// import com.ecommerce.returnmanager.model.ReturnRequest;
// import com.ecommerce.returnmanager.model.User;
// import com.ecommerce.returnmanager.repository.OrderItemRepository;
// import com.ecommerce.returnmanager.repository.ReturnRequestRepository;
// import com.ecommerce.returnmanager.service.impl.ReturnRequestServiceImpl;  // Add this import

// @ExtendWith(MockitoExtension.class)
// class ReturnRequestServiceTest {

//     @Mock
//     private ReturnRequestRepository returnRequestRepository;

//     @Mock
//     private OrderItemRepository orderItemRepository;

//     @Mock
//     private AuditLogger auditLogger;  // ADD THIS LINE

//     @Mock
//     private EmailService emailService;  // ADD THIS LINE

//     @InjectMocks
//     private ReturnRequestServiceImpl returnRequestService;

//     private User testUser;
//     private Order testOrder;
//     private OrderItem testOrderItem;
//     private ReturnRequest testReturnRequest;

//     @BeforeEach
//     void setUp() {
//     testUser = new User(1L, "Test User", "test@test.com", "password", User.Role.CUSTOMER);
    
//     testOrder = new Order();
//     testOrder.setId(1L);
//     testOrder.setUser(testUser);
//     testOrder.setOrderDate(LocalDateTime.now().minusDays(5));
//     testOrder.setStatus(Order.OrderStatus.DELIVERED);
    
//     testOrderItem = new OrderItem(1L, "Test Product", 2, new BigDecimal("50.00"), testOrder, null);
    
//     testReturnRequest = new ReturnRequest();
//     testReturnRequest.setId(1L);
//     testReturnRequest.setUser(testUser);
//     testReturnRequest.setOrderItem(testOrderItem);
//     testReturnRequest.setOrderId(1L); // Set orderId to avoid null constraint
//     testReturnRequest.setQuantityReturned(1);
//     testReturnRequest.setReason(ReturnRequest.ReturnReason.DAMAGED);
//     testReturnRequest.setStatus(ReturnRequest.ReturnStatus.PENDING);
//     testReturnRequest.setRefundAmount(new BigDecimal("50.00")); // ADD THIS LINE
// }

//     @Test
//     void initiateReturn_WithValidRequest_ShouldCreateReturn() {
//         when(orderItemRepository.findById(1L)).thenReturn(Optional.of(testOrderItem));
//         when(returnRequestRepository.save(any(ReturnRequest.class))).thenReturn(testReturnRequest);

//         ReturnRequest result = returnRequestService.initiateReturn(testReturnRequest);

//         assertNotNull(result);
//         assertEquals(ReturnRequest.ReturnStatus.PENDING, result.getStatus());
//         verify(returnRequestRepository, times(1)).save(any(ReturnRequest.class));
//     }

//     @Test
//     void getAllPendingRequests_ShouldReturnPendingRequests() {
//         ReturnRequest pendingRequest = new ReturnRequest();
//         pendingRequest.setStatus(ReturnRequest.ReturnStatus.PENDING);
        
//         ReturnRequest approvedRequest = new ReturnRequest();
//         approvedRequest.setStatus(ReturnRequest.ReturnStatus.APPROVED);

//         when(returnRequestRepository.findAll()).thenReturn(Arrays.asList(pendingRequest, approvedRequest));

//         List<ReturnRequest> result = returnRequestService.getAllPendingRequests();

//         assertFalse(result.isEmpty());
//         assertEquals(1, result.size());
//         assertEquals(ReturnRequest.ReturnStatus.PENDING, result.get(0).getStatus());
//     }

//     @Test
//     void approveRequest_WithPendingRequest_ShouldApprove() {
//         when(returnRequestRepository.findById(1L)).thenReturn(Optional.of(testReturnRequest));
//         when(returnRequestRepository.save(any(ReturnRequest.class))).thenReturn(testReturnRequest);

//         ReturnRequest result = returnRequestService.approveRequest(1L, "Approved for refund");

//         assertNotNull(result);
//         assertEquals(ReturnRequest.ReturnStatus.REFUNDED, result.getStatus());
//         assertNotNull(result.getResolutionDate());
//         assertEquals("Approved for refund", result.getAdminNotes());
//     }

//     @Test
//     void rejectRequest_WithPendingRequest_ShouldReject() {
//         when(returnRequestRepository.findById(1L)).thenReturn(Optional.of(testReturnRequest));
//         when(returnRequestRepository.save(any(ReturnRequest.class))).thenReturn(testReturnRequest);

//         ReturnRequest result = returnRequestService.rejectRequest(1L, "Item not eligible");

//         assertNotNull(result);
//         assertEquals(ReturnRequest.ReturnStatus.REJECTED, result.getStatus());
//         assertNotNull(result.getResolutionDate());
//         assertEquals("Item not eligible", result.getAdminNotes());
//     }
// }

--- File: src/test/java/com/ecommerce/returnmanager/service/ReturnRequestServiceIntegrationTest.java ---

package com.ecommerce.returnmanager.service;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;

import com.ecommerce.returnmanager.model.Order;
import com.ecommerce.returnmanager.model.OrderItem;
import com.ecommerce.returnmanager.model.ReturnRequest;
import com.ecommerce.returnmanager.model.User;
import com.ecommerce.returnmanager.repository.OrderItemRepository;
import com.ecommerce.returnmanager.repository.OrderRepository;
import com.ecommerce.returnmanager.repository.ReturnRequestRepository;
import com.ecommerce.returnmanager.repository.UserRepository;

@SpringBootTest
@ActiveProfiles("test")
@Transactional
class ReturnRequestServiceIntegrationTest {

    @Autowired
    private ReturnRequestService returnRequestService;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private OrderItemRepository orderItemRepository;

    @Autowired
    private ReturnRequestRepository returnRequestRepository;

    private User testUser;
    private Order testOrder;
    private OrderItem testOrderItem;

    @BeforeEach
    void setUp() {
        // Clean up any existing test data
        returnRequestRepository.deleteAll();
        orderItemRepository.deleteAll();
        orderRepository.deleteAll();
        userRepository.deleteAll();

        // Create test user
        testUser = new User();
        testUser.setName("Test User");
        testUser.setEmail("test@test.com");
        testUser.setPassword("password");
        testUser.setRole(User.Role.CUSTOMER);
        testUser = userRepository.save(testUser);

        // Create test order
        testOrder = new Order();
        testOrder.setUser(testUser);
        testOrder.setOrderDate(LocalDateTime.now().minusDays(5)); // Within 30-day window
        testOrder.setStatus(Order.OrderStatus.DELIVERED);
        testOrder.setTotalAmount(100.00);
        testOrder = orderRepository.save(testOrder);

        // Create test order item
        testOrderItem = new OrderItem();
        testOrderItem.setProductName("Test Product");
        testOrderItem.setQuantity(2);
        testOrderItem.setPricePerItem(new BigDecimal("50.00"));
        testOrderItem.setOrder(testOrder);
        testOrderItem = orderItemRepository.save(testOrderItem);
    }

    @Test
    void initiateReturn_WithValidData_ShouldCreateReturnRequest() {
        ReturnRequest returnRequest = new ReturnRequest();
        returnRequest.setOrderItem(testOrderItem);
        returnRequest.setUser(testUser);
        returnRequest.setOrderId(testOrder.getId()); // Set orderId to avoid constraint violation
        returnRequest.setQuantityReturned(1);
        returnRequest.setReason(ReturnRequest.ReturnReason.DAMAGED);

        ReturnRequest result = returnRequestService.initiateReturn(returnRequest);

        assertNotNull(result.getId());
        assertEquals(ReturnRequest.ReturnStatus.PENDING, result.getStatus());
        assertEquals(new BigDecimal("50.00"), result.getRefundAmount());
        assertNotNull(result.getRequestDate());
    }

    @Test
    void getAllPendingRequests_ShouldReturnOnlyPendingRequests() {
        // Create a pending request
        ReturnRequest pendingRequest = new ReturnRequest();
        pendingRequest.setOrderItem(testOrderItem);
        pendingRequest.setUser(testUser);
        pendingRequest.setOrderId(testOrder.getId()); // Set orderId
        pendingRequest.setQuantityReturned(1);
        pendingRequest.setReason(ReturnRequest.ReturnReason.DAMAGED);
        pendingRequest.setStatus(ReturnRequest.ReturnStatus.PENDING);
        returnRequestRepository.save(pendingRequest);

        List<ReturnRequest> pendingRequests = returnRequestService.getAllPendingRequests();

        assertEquals(1, pendingRequests.size());
        assertEquals(ReturnRequest.ReturnStatus.PENDING, pendingRequests.get(0).getStatus());
    }
}

--- File: src/main/resources/application.properties ---

# Server Configuration
server.port=8080

# MySQL Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/return_refund_db?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true
spring.datasource.username=rupesh
spring.datasource.password=Rupeshsah@5920
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA/Hibernate Settings for Development
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

# Spring Boot Application Name
spring.application.name=return-refund-manager

# MVC Configuration
spring.mvc.pathmatch.use-trailing-slash-match=true
spring.mvc.pathmatch.matching-strategy=ant_path_matcher

# Thymeleaf Configuration
spring.thymeleaf.cache=false

# Session Management
server.servlet.session.timeout=30m
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.secure=false

# OpenAPI/Swagger Configuration
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.tagsSorter=alpha
springdoc.version=1.0.0

# Show actuator endpoints (optional)
management.endpoints.web.exposure.include=health,info,metrics

# Database Connection Pool Settings
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.maximum-pool-size=5

--- File: src/main/resources/templates/return-form.html ---

<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Initiate Return Request</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 600px; margin: auto; padding: 20px; border: 1px solid #ccc; border-radius: 8px; }
        h1 { color: #333; }
        label { display: block; margin-top: 10px; font-weight: bold; }
        input, select { width: 100%; padding: 8px; margin-top: 4px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
        button { background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin-top: 20px; }
        .error { color: red; margin-top: 10px; }
        .user-info { background-color: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 20px; }
        .nav-links { margin-top: 15px; }
        .nav-links a { color: #007bff; text-decoration: none; margin-right: 15px; }
        .nav-links a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container">
        <!-- User Authentication Info -->
        <div th:if="${username}" class="user-info">
            <p>Welcome, <strong th:text="${username}"></strong> 
               <span th:if="${isAdmin}">(Admin)</span>
               <span th:unless="${isAdmin}">(Customer)</span>
            </p>
            <div class="nav-links">
                <a th:href="@{/logout}">Logout</a>
                <a th:if="${isAdmin}" th:href="@{/admin/dashboard}">Admin Dashboard</a>
                <a th:unless="${isAdmin}" th:href="@{/}">Return Form</a>
            </div>
        </div>
        
        <h1>Initiate Return Request</h1>
        
        <p th:if="${error}" class="error" th:text="${error}"></p>
        
        <form th:action="@{/submit-return}" th:object="${returnRequest}" method="post">
            
            <label for="orderItemId">Order Item ID:</label>
            <input type="number" id="orderItemId" th:field="*{orderItem.id}" required/>

            <label for="quantityReturned">Quantity to Return (Max: 10):</label>
            <input type="number" id="quantityReturned" th:field="*{quantityReturned}" min="1" max="10" required/>

            <label for="reason">Reason for Return:</label>
            <select id="reason" th:field="*{reason}" required>
                <option value="">-- Select Reason --</option>
                <option th:each="reason : ${reasons}" 
                        th:value="${reason}" 
                        th:text="${reason.toString().replace('_', ' ')}"></option>
            </select>
            
            <button type="submit">Submit Return Request</button>
        </form>
        
        <p style="margin-top: 30px;">
            **Test Data Tip:** Use **Order Item ID 1** from your TestDataInitializer to test a successful return.
        </p>
    </div>
</body>
</html>

--- File: src/main/resources/templates/login.html ---

<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Login - Return Manager</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background-color: #f5f5f5; }
        .login-container { max-width: 400px; margin: 100px auto; padding: 30px; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h2 { text-align: center; color: #333; margin-bottom: 30px; }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; }
        input[type="email"], input[type="password"] { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
        button { width: 100%; padding: 12px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; }
        button:hover { background-color: #0056b3; }
        .error { color: red; text-align: center; margin-top: 15px; }
        .success { color: green; text-align: center; margin-top: 15px; }
        .test-accounts { margin-top: 30px; padding: 15px; background: #f8f9fa; border-radius: 5px; }
        .test-accounts h4 { margin-top: 0; }
    </style>
</head>
<body>
    <div class="login-container">
        <h2>Return Manager Login</h2>
        
        <!-- Error Message -->
        <div th:if="${param.error}" class="error">
            Invalid email or password.
        </div>
        
        <!-- Logout Message -->
        <div th:if="${param.logout}" class="success">
            You have been logged out successfully.
        </div>
        
        <form th:action="@{/login}" method="post">
            <div class="form-group">
                <label for="username">Email:</label>
                <input type="email" id="username" name="username" required autofocus>
            </div>
            
            <div class="form-group">
                <label for="password">Password:</label>
                <input type="password" id="password" name="password" required>
            </div>
            
            <button type="submit">Sign In</button>
        </form>

        <div class="test-accounts">
            <h4>Test Accounts:</h4>
            <p><strong>Customer:</strong> alice@test.com / password123</p>
            <p><strong>Admin:</strong> bob@admin.com / adminpass</p>
        </div>
    </div>
</body>
</html>

--- File: src/main/resources/templates/admin-dashboard.html ---

<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Admin Return Dashboard</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { color: #333; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .success { color: green; font-weight: bold; }
        .error { color: red; font-weight: bold; }
        .action-container { display: flex; flex-direction: column; gap: 5px; }
        .action-form { display: flex; gap: 5px; align-items: center; }
        input[type="text"] { padding: 5px; border: 1px solid #ccc; border-radius: 3px; }
        button { padding: 5px 10px; border: none; border-radius: 3px; cursor: pointer; color: white; }
        .approve-btn { background-color: #4CAF50; }
        .reject-btn { background-color: #f44336; }
        .user-info { background-color: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 20px; }
        .nav-links { margin-top: 10px; }
        .nav-links a { color: #007bff; text-decoration: none; margin-right: 15px; }
        .nav-links a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <!-- User Authentication Info -->
    <div th:if="${username}" class="user-info">
        <p>Welcome, Admin: <strong th:text="${username}"></strong></p>
        <div class="nav-links">
            <a th:href="@{/logout}">Logout</a>
            <a th:href="@{/}">Return to Home</a>
            <a th:href="@{/admin/dashboard}">Refresh Dashboard</a>
        </div>
    </div>

    <h1>Admin Return Dashboard - Pending Requests</h1>

    <div th:if="${success}" class="success" th:text="${success}"></div>
    <div th:if="${error}" class="error" th:text="${error}"></div>

    <table th:if="${!requests.isEmpty()}">
        <thead>
            <tr>
                <th>ID</th>
                <th>Order Item ID</th>
                <th>Customer</th>
                <th>Product</th>
                <th>Quantity</th>
                <th>Reason</th>
                <th>Refund Amount</th>
                <th>Date Requested</th>
                <th>Action</th>
            </tr>
        </thead>
        <tbody>
            <tr th:each="request : ${requests}">
                <td th:text="${request.id}">1</td>
                <td th:text="${request.orderItem.id}">101</td>
                <td th:text="${request.user.name}">Alice Customer</td>
                <td th:text="${request.orderItem.productName}">Bluetooth Headphones</td>
                <td th:text="${request.quantityReturned}">1</td>
                <td th:text="${request.reason}">DAMAGED</td>
                <td>$<span th:text="${#numbers.formatDecimal(request.refundAmount, 0, 'COMMA', 2, 'POINT')}">100.00</span></td>
                <td th:text="${#temporals.format(request.requestDate, 'yyyy-MM-dd HH:mm')}">2025-10-19</td>
                <td>
                    <div class="action-container">
                        <!-- Approve Form -->
                        <form th:action="@{/admin/approve/{id}(id=${request.id})}" method="post" class="action-form">
                            <input type="text" name="adminNotes" placeholder="Approval notes..." required>
                            <button type="submit" class="approve-btn">Approve</button>
                        </form>
                        
                        <!-- Reject Form -->
                        <form th:action="@{/admin/reject/{id}(id=${request.id})}" method="post" class="action-form">
                            <input type="text" name="adminNotes" placeholder="Rejection reason..." required>
                            <button type="submit" class="reject-btn">Reject</button>
                        </form>
                    </div>
                </td>
            </tr>
        </tbody>
    </table>
    
    <div th:unless="${!requests.isEmpty()}">
        <p>No pending return requests found. Good job!</p>
    </div>

</body>
</html>

--- File: src/main/resources/templates/return-success.html ---

<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Return Submitted</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 600px; margin: auto; padding: 20px; border: 1px solid #4CAF50; background-color: #e8f5e9; border-radius: 8px; }
        h1 { color: #4CAF50; }
        p { margin-top: 10px; }
        .detail { background-color: #fff; padding: 10px; border-radius: 4px; margin-top: 10px; }
        a { color: #007bff; text-decoration: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Return Request Submitted!</h1>
        <p th:text="${message}"></p>

        <h2>Request Details:</h2>
        <div class="detail">
            <p><strong>Request ID:</strong> <span th:text="${details.id}"></span></p>
            <p><strong>Status:</strong> <span th:text="${details.status}"></span></p>
            <p><strong>Reason:</strong> <span th:text="${details.reason}"></span></p>
            <p><strong>Quantity Returned:</strong> <span th:text="${details.quantityReturned}"></span></p>
            <p><strong>Initial Refund Amount:</strong> $<span th:text="${#numbers.formatDecimal(details.refundAmount, 0, 'COMMA', 2, 'POINT')}"></span></p>
        </div>
        
        <p style="margin-top: 20px;"><a th:href="@{/}">Submit another return</a></p>
    </div>
</body>
</html>

--- File: src/main/java/com/ecommerce/returnmanager/ReturnRefundManagerApplication.java ---

package com.ecommerce.returnmanager;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ReturnRefundManagerApplication {

	public static void main(String[] args) {
		SpringApplication.run(ReturnRefundManagerApplication.class, args);
	}

}


--- File: src/main/java/com/ecommerce/returnmanager/TestDataInitializer.java ---

package com.ecommerce.returnmanager;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Arrays;

import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Profile;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import com.ecommerce.returnmanager.model.Order;
import com.ecommerce.returnmanager.model.Order.OrderStatus;
import com.ecommerce.returnmanager.model.OrderItem;
import com.ecommerce.returnmanager.model.ReturnRequest;
import com.ecommerce.returnmanager.model.User;
import com.ecommerce.returnmanager.model.User.Role;
import com.ecommerce.returnmanager.repository.OrderItemRepository;
import com.ecommerce.returnmanager.repository.OrderRepository;
import com.ecommerce.returnmanager.repository.ReturnRequestRepository;
import com.ecommerce.returnmanager.repository.UserRepository;

/**
 * Initializes the database with sample data upon application startup.
 * This simulates a user, their order, and a pending return request.
 */
@Component
@Profile("!test") // Don't run this during tests
public class TestDataInitializer implements CommandLineRunner {

    private final UserRepository userRepository;
    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final ReturnRequestRepository returnRequestRepository;
    private final PasswordEncoder passwordEncoder;

    public TestDataInitializer(UserRepository userRepository, OrderRepository orderRepository,
                               OrderItemRepository orderItemRepository, ReturnRequestRepository returnRequestRepository,
                               PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.orderRepository = orderRepository;
        this.orderItemRepository = orderItemRepository;
        this.returnRequestRepository = returnRequestRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public void run(String... args) throws Exception {
        if (userRepository.count() > 0) {
            System.out.println("--- Database already initialized. Skipping sample data insertion. ---");
            return;
        }
        System.out.println("--- Inserting Sample Data with Encrypted Passwords ---");
        
        // 1. Create Users with ENCRYPTED passwords
        User customer = new User(null, "Alice Customer", "alice@test.com", 
                               passwordEncoder.encode("password123"), Role.CUSTOMER);
        User admin = new User(null, "Bob Admin", "bob@admin.com", 
                             passwordEncoder.encode("adminpass"), Role.ADMIN);
        customer = userRepository.save(customer);
        admin = userRepository.save(admin);

        // 2. Create Order (Delivered 10 days ago, making it eligible for return)
        Order order1 = new Order();
        order1.setUser(customer);
        order1.setOrderDate(LocalDateTime.now().minusDays(35)); // Order placed 35 days ago (TOO LATE for 30-day policy)
        order1.setStatus(OrderStatus.DELIVERED);
        order1.setTotalAmount(150.00); 
        order1 = orderRepository.save(order1);

        Order order2 = new Order();
        order2.setUser(customer);
        order2.setOrderDate(LocalDateTime.now().minusDays(10)); // Order placed 10 days ago (ELIGIBLE)
        order2.setStatus(OrderStatus.DELIVERED);
        order2.setTotalAmount(250.00);
        order2 = orderRepository.save(order2);
        
        // 3. Create Order Items for Order 2 (ELIGIBLE)
        OrderItem itemA = new OrderItem(null, "Bluetooth Headphones", 1, new BigDecimal("100.00"), order2, null);
        OrderItem itemB = new OrderItem(null, "Charging Cable", 2, new BigDecimal("25.00"), order2, null);
        itemA.setOrder(order2);
        itemB.setOrder(order2);
        
        itemA = orderItemRepository.save(itemA);
        itemB = orderItemRepository.save(itemB);

        // Update Order 2 with items
        order2.setItems(Arrays.asList(itemA, itemB));
        orderRepository.save(order2);

        // 4. Create a Pending Return Request for itemA (VALID)
        ReturnRequest request1 = new ReturnRequest();
        request1.setOrderItem(itemA);
        request1.setUser(customer);
        request1.setQuantityReturned(1);
        request1.setReason(ReturnRequest.ReturnReason.DAMAGED);
        request1.setStatus(ReturnRequest.ReturnStatus.PENDING);
        request1.setRefundAmount(new BigDecimal("100.00")); // Will be recalculated in service layer
        request1.setRequestDate(LocalDateTime.now());
        returnRequestRepository.save(request1);
        
        System.out.println("--- Sample Data Insertion Complete ---");
        System.out.println("Test Accounts Created:");
        System.out.println("Customer: alice@test.com / password123");
        System.out.println("Admin: bob@admin.com / adminpass");
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/dto/ApiResponse.java ---

package com.ecommerce.returnmanager.dto;

import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonInclude;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
    private String timestamp;
    private String error;

    // Success static methods
    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, "Operation successful", data, LocalDateTime.now().toString(), null);
    }

    public static <T> ApiResponse<T> success(String message, T data) {
        return new ApiResponse<>(true, message, data, LocalDateTime.now().toString(), null);
    }

    public static <T> ApiResponse<T> success(String message) {
        return new ApiResponse<>(true, message, null, LocalDateTime.now().toString(), null);
    }

    // Error static methods
    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(false, null, null, LocalDateTime.now().toString(), message);
    }

    public static <T> ApiResponse<T> error(String message, String error) {
        return new ApiResponse<>(false, null, null, LocalDateTime.now().toString(), error);
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/dto/ErrorResponse.java ---

package com.ecommerce.returnmanager.dto;

import java.time.LocalDateTime;
import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorResponse {
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    private List<FieldError> fieldErrors;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class FieldError {
        private String field;
        private String message;
        private Object rejectedValue;
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/repository/OrderRepository.java ---

package com.ecommerce.returnmanager.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.ecommerce.returnmanager.model.Order;

public interface OrderRepository extends JpaRepository<Order, Long> {
    List<Order> findByUserId(Long userId);
}

--- File: src/main/java/com/ecommerce/returnmanager/repository/ReturnRequestRepository.java ---

package com.ecommerce.returnmanager.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.ecommerce.returnmanager.model.ReturnRequest;

public interface ReturnRequestRepository extends JpaRepository<ReturnRequest, Long> {
    List<ReturnRequest> findByUserId(Long userId);
}

--- File: src/main/java/com/ecommerce/returnmanager/repository/UserRepository.java ---

package com.ecommerce.returnmanager.repository;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;

import com.ecommerce.returnmanager.model.User;

public interface UserRepository extends JpaRepository<User, Long> {
    // Custom find methods can be added here later (e.g., findByEmail)
    
    // Add this method for Spring Security authentication
    Optional<User> findByEmail(String email);
}

--- File: src/main/java/com/ecommerce/returnmanager/repository/OrderItemRepository.java ---

package com.ecommerce.returnmanager.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.ecommerce.returnmanager.model.OrderItem;

public interface OrderItemRepository extends JpaRepository<OrderItem, Long> {
    // No custom methods needed yet, basic CRUD provided by JpaRepository
}

--- File: src/main/java/com/ecommerce/returnmanager/config/SecurityConfig.java ---

package com.ecommerce.returnmanager.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final CustomAuthSuccessHandler customAuthSuccessHandler;

    public SecurityConfig(CustomAuthSuccessHandler customAuthSuccessHandler) {
        this.customAuthSuccessHandler = customAuthSuccessHandler;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authz -> authz
                // Public endpoints - no authentication required
                .requestMatchers("/", "/login", "/submit-return", "/css/**", "/js/**", "/images/**").permitAll()
                
                // Admin endpoints - require ADMIN role
                .requestMatchers("/admin/**", "/api/v1/admin/**").hasRole("ADMIN")
                
                // Customer API endpoints - require CUSTOMER role  
                .requestMatchers("/api/v1/customer/returns/**").hasRole("CUSTOMER")
                
                // All other requests require authentication
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage("/login")
                .successHandler(customAuthSuccessHandler) // Use custom success handler
                .failureUrl("/login?error=true")
                .permitAll()
            )
            .logout(logout -> logout
                .logoutSuccessUrl("/login?logout=true")
                .permitAll()
            )
            .sessionManagement(session -> session
            .maximumSessions(1)
            .maxSessionsPreventsLogin(false)
        )
        .headers(headers -> headers
            .contentSecurityPolicy(csp -> csp
                .policyDirectives("default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'")
            )
        )
        .csrf(csrf -> csrf.disable()); // Disable CSRF for API development

    return http.build();
}
}

--- File: src/main/java/com/ecommerce/returnmanager/config/OpenApiConfig.java ---

package com.ecommerce.returnmanager.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("Return & Refund Management System API")
                .description("""
                    A comprehensive REST API for managing product returns and refunds in an e-commerce system.
                    
                    ## Features:
                    - Customers can initiate return requests
                    - Admins can approve/reject return requests  
                    - Automatic refund calculation
                    - 30-day return window validation
                    - Role-based access control
                    
                    ## Authentication:
                    - Form-based login for web interface
                    - Basic Auth for API endpoints
                    - Role-based authorization (CUSTOMER/ADMIN)
                    """)
                .version("1.0.0")
                .contact(new Contact()
                    .name("API Support")
                    .email("support@ecommerce.com"))
                .license(new License()
                    .name("Apache 2.0")
                    .url("http://springdoc.org")))
            .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
            .components(new Components()
                .addSecuritySchemes("bearerAuth", new SecurityScheme()
                    .name("bearerAuth")
                    .type(SecurityScheme.Type.HTTP)
                    .scheme("bearer")
                    .bearerFormat("JWT")));
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/config/RateLimitInterceptor.java ---

package com.ecommerce.returnmanager.config;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component
public class RateLimitInterceptor implements HandlerInterceptor {
    
    private final ConcurrentHashMap<String, RequestCounter> requestCounts = new ConcurrentHashMap<>();
    private static final int MAX_REQUESTS_PER_MINUTE = 60; // 60 requests per minute
    private static final long TIME_WINDOW_MS = TimeUnit.MINUTES.toMillis(1);

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String clientIp = getClientIp(request);
        String path = request.getRequestURI();
        
        // Skip rate limiting for admin endpoints (they have different limits)
        if (path.contains("/admin/")) {
            return true;
        }
        
        String key = clientIp + ":" + path;
        RequestCounter counter = requestCounts.computeIfAbsent(key, k -> new RequestCounter());
        
        if (counter.isRateLimited()) {
            response.setStatus(429); // Too Many Requests
            response.getWriter().write("Rate limit exceeded. Please try again later.");
            return false;
        }
        
        counter.increment();
        return true;
    }
    
    private String getClientIp(HttpServletRequest request) {
        String xfHeader = request.getHeader("X-Forwarded-For");
        if (xfHeader != null) {
            return xfHeader.split(",")[0];
        }
        return request.getRemoteAddr();
    }
    
    private static class RequestCounter {
        private long windowStart;
        private int count;
        
        RequestCounter() {
            this.windowStart = System.currentTimeMillis();
            this.count = 0;
        }
        
        synchronized boolean isRateLimited() {
            long now = System.currentTimeMillis();
            if (now - windowStart > TIME_WINDOW_MS) {
                // Reset counter for new time window
                windowStart = now;
                count = 0;
                return false;
            }
            return count >= MAX_REQUESTS_PER_MINUTE;
        }
        
        synchronized void increment() {
            count++;
        }
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/config/CustomAuthSuccessHandler.java ---

package com.ecommerce.returnmanager.config;

import java.io.IOException;
import java.util.Collection;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.stereotype.Component;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component
public class CustomAuthSuccessHandler implements AuthenticationSuccessHandler {

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, 
                                      HttpServletResponse response, 
                                      Authentication authentication) throws IOException, ServletException {
        
        Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
        
        // Check if user has ADMIN role
        boolean isAdmin = authorities.stream()
                .anyMatch(grantedAuthority -> grantedAuthority.getAuthority().equals("ROLE_ADMIN"));
        
        // Redirect based on role
        if (isAdmin) {
            response.sendRedirect("/admin/dashboard");
        } else {
            response.sendRedirect("/");
        }
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/config/RateLimitConfig.java ---

package com.ecommerce.returnmanager.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class RateLimitConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new RateLimitInterceptor())
                .addPathPatterns("/api/v1/**")
                .excludePathPatterns("/api-docs/**", "/swagger-ui/**");
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/config/AuditLogger.java ---

package com.ecommerce.returnmanager.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
public class AuditLogger {
    
    private static final Logger logger = LoggerFactory.getLogger("AUDIT");
    private static final Logger securityLogger = LoggerFactory.getLogger("SECURITY");
    private static final Logger performanceLogger = LoggerFactory.getLogger("PERFORMANCE");

    public void logReturnCreation(Long requestId, String userEmail, String productName) {
        logger.info("RETURN_CREATED | RequestID: {} | User: {} | Product: {}", 
                   requestId, userEmail, productName);
    }

    public void logReturnApproval(Long requestId, String adminEmail, Double refundAmount) {
        logger.info("RETURN_APPROVED | RequestID: {} | Admin: {} | Refund: ${}", 
                   requestId, adminEmail, refundAmount);
    }

    public void logReturnRejection(Long requestId, String adminEmail, String reason) {
        logger.info("RETURN_REJECTED | RequestID: {} | Admin: {} | Reason: {}", 
                   requestId, adminEmail, reason);
    }

    public void logSecurityEvent(String event, String userEmail, String details) {
        securityLogger.warn("SECURITY_EVENT | Event: {} | User: {} | Details: {}", 
                          event, userEmail, details);
    }

    public void logPerformance(String operation, long durationMs) {
        performanceLogger.info("PERFORMANCE | Operation: {} | Duration: {}ms", 
                              operation, durationMs);
    }

    public void logError(String operation, String error, String userEmail) {
        logger.error("ERROR | Operation: {} | User: {} | Error: {}", 
                    operation, userEmail, error);
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/controller/WebController.java ---

package com.ecommerce.returnmanager.controller;

import java.util.Arrays;
import java.util.List;
import java.util.NoSuchElementException;

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.ecommerce.returnmanager.model.ReturnRequest;
import com.ecommerce.returnmanager.model.ReturnRequest.ReturnReason;
import com.ecommerce.returnmanager.model.User;
import com.ecommerce.returnmanager.repository.UserRepository;
import com.ecommerce.returnmanager.service.ReturnRequestService;

@Controller
@RequestMapping("/")
public class WebController {

    private final ReturnRequestService returnRequestService;
    private final UserRepository userRepository;

    public WebController(ReturnRequestService returnRequestService, UserRepository userRepository) {
        this.returnRequestService = returnRequestService;
        this.userRepository = userRepository;
    }

    /**
     * Serves the return request form page.
     */
    @GetMapping
    public String showReturnForm(Model model, @AuthenticationPrincipal UserDetails userDetails) {
        model.addAttribute("returnRequest", new ReturnRequest());
        
        List<ReturnReason> reasons = Arrays.asList(ReturnReason.values());
        model.addAttribute("reasons", reasons);
        
        // Add username and role info to model if user is authenticated
        if (userDetails != null) {
            model.addAttribute("username", userDetails.getUsername());
            
            // Check if user is admin for UI display
            boolean isAdmin = userDetails.getAuthorities().stream()
                    .anyMatch(grantedAuthority -> grantedAuthority.getAuthority().equals("ROLE_ADMIN"));
            model.addAttribute("isAdmin", isAdmin);
        }
        
        return "return-form";
    }

    /**
     * Handles the customer form submission.
     */
    @PostMapping("/submit-return")
    public String processReturn(@ModelAttribute("returnRequest") ReturnRequest request, 
                               Model model, 
                               @AuthenticationPrincipal UserDetails userDetails) {
        try {
            // Use authenticated user instead of hardcoded ID
            if (userDetails == null) {
                throw new SecurityException("User not authenticated. Please log in to submit a return request.");
            }
            
            User customer = userRepository.findByEmail(userDetails.getUsername())
                .orElseThrow(() -> new NoSuchElementException("Authenticated user not found. Cannot process return."));
            
            request.setUser(customer);
            
            ReturnRequest createdRequest = returnRequestService.initiateReturn(request);
            
            model.addAttribute("message", "Return Request Submitted Successfully!");
            model.addAttribute("details", createdRequest);
            
            // Add username to success page
            if (userDetails != null) {
                model.addAttribute("username", userDetails.getUsername());
                
                // Check if user is admin for UI display
                boolean isAdmin = userDetails.getAuthorities().stream()
                        .anyMatch(grantedAuthority -> grantedAuthority.getAuthority().equals("ROLE_ADMIN"));
                model.addAttribute("isAdmin", isAdmin);
            }
            
            return "return-success";

        } catch (Exception e) {
            model.addAttribute("error", "Failed to submit return: " + e.getMessage());
            model.addAttribute("returnRequest", request);
            model.addAttribute("reasons", Arrays.asList(ReturnReason.values()));
            
            // Add username back to form in case of error
            if (userDetails != null) {
                model.addAttribute("username", userDetails.getUsername());
                
                // Check if user is admin for UI display
                boolean isAdmin = userDetails.getAuthorities().stream()
                        .anyMatch(grantedAuthority -> grantedAuthority.getAuthority().equals("ROLE_ADMIN"));
                model.addAttribute("isAdmin", isAdmin);
            }
            
            return "return-form";
        }
    }

    // --- ADMIN CONTROLLER LOGIC STARTS HERE ---

    /**
     * Serves the admin dashboard showing all PENDING requests.
     */
    @GetMapping("/admin/dashboard")
    public String showAdminDashboard(Model model, @AuthenticationPrincipal UserDetails userDetails) {
        List<ReturnRequest> pendingRequests = returnRequestService.getAllPendingRequests();
        model.addAttribute("requests", pendingRequests);
        
        // Add admin username to model
        if (userDetails != null) {
            model.addAttribute("username", userDetails.getUsername());
            model.addAttribute("isAdmin", true); // This is admin page, so always true
        }
        
        return "admin-dashboard";
    }

    /**
     * Handles the approval of a return request.
     */
    @PostMapping(value = {"/admin/approve/{id}", "/admin/approve/{id}/"}) 
    public String approveReturn(@PathVariable Long id, 
                               @RequestParam String adminNotes, 
                               RedirectAttributes redirectAttributes,
                               @AuthenticationPrincipal UserDetails userDetails) {
        try {
            returnRequestService.approveRequest(id, adminNotes);
            redirectAttributes.addFlashAttribute("success", "Request ID " + id + " Approved and Refunded successfully.");
        } catch (Exception e) {
            redirectAttributes.addFlashAttribute("error", "Failed to approve request: " + e.getMessage());
        }
        return "redirect:/admin/dashboard"; 
    }

    /**
     * Handles the rejection of a return request.
     */
    @PostMapping(value = {"/admin/reject/{id}", "/admin/reject/{id}/"})
    public String rejectReturn(@PathVariable Long id, 
                              @RequestParam String adminNotes, 
                              RedirectAttributes redirectAttributes,
                              @AuthenticationPrincipal UserDetails userDetails) {
        try {
            returnRequestService.rejectRequest(id, adminNotes);
            redirectAttributes.addFlashAttribute("success", "Request ID " + id + " Rejected successfully.");
        } catch (Exception e) {
            redirectAttributes.addFlashAttribute("error", "Failed to reject request: " + e.getMessage());
        }
        return "redirect:/admin/dashboard"; 
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/controller/DashboardController.java ---

package com.ecommerce.returnmanager.controller;

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class DashboardController {

    @GetMapping("/dashboard")
    public String showDashboard(@AuthenticationPrincipal UserDetails userDetails) {
        if (userDetails != null) {
            boolean isAdmin = userDetails.getAuthorities().stream()
                    .anyMatch(grantedAuthority -> grantedAuthority.getAuthority().equals("ROLE_ADMIN"));
            
            if (isAdmin) {
                return "redirect:/admin/dashboard";
            } else {
                return "redirect:/";
            }
        }
        return "redirect:/login";
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/controller/CustomerReturnController.java ---

package com.ecommerce.returnmanager.controller;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.ecommerce.returnmanager.dto.ApiResponse;
import com.ecommerce.returnmanager.model.ReturnRequest;
import com.ecommerce.returnmanager.model.User;
import com.ecommerce.returnmanager.repository.ReturnRequestRepository;
import com.ecommerce.returnmanager.repository.UserRepository;
import com.ecommerce.returnmanager.service.ReturnRequestService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/v1/customer/returns")
@Tag(name = "Customer Return Management", description = "APIs for customers to manage their return requests")
public class CustomerReturnController {

    private final ReturnRequestService returnRequestService;
    private final ReturnRequestRepository returnRequestRepository;
    private final UserRepository userRepository;

    public CustomerReturnController(ReturnRequestService returnRequestService, UserRepository userRepository, ReturnRequestRepository rrr) {
        this.returnRequestService = returnRequestService;
        this.userRepository = userRepository;
        this.returnRequestRepository = rrr;
    }

    @Operation(
        summary = "Initiate a return request",
        description = "Allows customers to submit a new return request for an order item"
    )
    @io.swagger.v3.oas.annotations.responses.ApiResponses({
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "201", description = "Return request created successfully", 
                    content = @Content(schema = @Schema(implementation = ReturnRequest.class))),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "400", description = "Invalid input data"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "401", description = "Unauthorized - user not authenticated"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "403", description = "Forbidden - user not authorized")
    })
    @PostMapping
    public ResponseEntity<ApiResponse<ReturnRequest>> initiateReturn(
            @Parameter(description = "Return request details") 
            @Valid @RequestBody ReturnRequest request,
            @AuthenticationPrincipal UserDetails userDetails) {
        try {
            if (userDetails == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(ApiResponse.error("User not authenticated. Please log in to submit a return request."));
            }
            
            User customer = userRepository.findByEmail(userDetails.getUsername())
                .orElseThrow(() -> new RuntimeException("Authenticated user not found in database."));
            
            request.setUser(customer);
            
            ReturnRequest createdRequest = returnRequestService.initiateReturn(request);
            
            return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success("Return request submitted successfully", createdRequest));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(ApiResponse.error(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("An unexpected error occurred: " + e.getMessage()));
        }
    }
    
    @Operation(
        summary = "Get return request details",
        description = "Retrieve details of a specific return request by ID"
    )
    @io.swagger.v3.oas.annotations.responses.ApiResponses({
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "200", description = "Return request found", 
                    content = @Content(schema = @Schema(implementation = ReturnRequest.class))),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "401", description = "Unauthorized"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "403", description = "Forbidden - user cannot access this return request"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "404", description = "Return request not found")
    })
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ReturnRequest>> getReturnDetails(
            @Parameter(description = "ID of the return request") @PathVariable Long id,
            @AuthenticationPrincipal UserDetails userDetails) {
        try {
            if (userDetails == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(ApiResponse.error("User not authenticated."));
            }
            
            Optional<ReturnRequest> request = returnRequestService.getRequestById(id);
            
            if (request.isEmpty()) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(ApiResponse.error("Return request not found with ID: " + id));
            }
            
            // Security check: Verify the return request belongs to the authenticated user
            ReturnRequest returnRequest = request.get();
            User currentUser = userRepository.findByEmail(userDetails.getUsername())
                .orElseThrow(() -> new RuntimeException("Authenticated user not found."));
            
            if (!returnRequest.getUser().getId().equals(currentUser.getId())) {
                return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(ApiResponse.error("Access denied. This return request does not belong to you."));
            }
            
            return ResponseEntity.ok(ApiResponse.success("Return request retrieved successfully", returnRequest));
            
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(ApiResponse.error(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("An unexpected error occurred: " + e.getMessage()));
        }
    }

    @Operation(
    summary = "Get customer's return history",
    description = "Retrieve all return requests for the authenticated customer"
)
@GetMapping("/history")
public ResponseEntity<ApiResponse<List<ReturnRequest>>> getCustomerReturnHistory(
        @AuthenticationPrincipal UserDetails userDetails) {
    try {
        if (userDetails == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body(ApiResponse.error("User not authenticated."));
        }
        
        User customer = userRepository.findByEmail(userDetails.getUsername())
            .orElseThrow(() -> new RuntimeException("Authenticated user not found."));
        
        List<ReturnRequest> returnRequests = returnRequestRepository.findByUserId(customer.getId());
        
        return ResponseEntity.ok(ApiResponse.success("Return history retrieved successfully", returnRequests));
        
    } catch (Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ApiResponse.error("Failed to retrieve return history: " + e.getMessage()));
    }
}

@Operation(
    summary = "Cancel a pending return request",
    description = "Allows customers to cancel their own pending return requests"
)
@PutMapping("/{id}/cancel")
public ResponseEntity<ApiResponse<ReturnRequest>> cancelReturnRequest(
        @Parameter(description = "ID of the return request to cancel") @PathVariable Long id,
        @AuthenticationPrincipal UserDetails userDetails) {
    try {
        if (userDetails == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body(ApiResponse.error("User not authenticated."));
        }
        
        User customer = userRepository.findByEmail(userDetails.getUsername())
            .orElseThrow(() -> new RuntimeException("Authenticated user not found."));
        
        ReturnRequest returnRequest = returnRequestRepository.findById(id)
            .orElseThrow(() -> new NoSuchElementException("Return request not found with ID: " + id));
        
        // Security check: Verify the return request belongs to the authenticated user
        if (!returnRequest.getUser().getId().equals(customer.getId())) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                .body(ApiResponse.error("Access denied. This return request does not belong to you."));
        }
        
        // Business rule: Only pending requests can be cancelled
        if (returnRequest.getStatus() != ReturnRequest.ReturnStatus.PENDING) {
            return ResponseEntity.status(HttpStatus.CONFLICT)
                .body(ApiResponse.error("Cannot cancel request. Only pending requests can be cancelled."));
        }
        
        returnRequest.setStatus(ReturnRequest.ReturnStatus.CLOSED);
        returnRequest.setAdminNotes("Cancelled by customer");
        ReturnRequest updatedRequest = returnRequestRepository.save(returnRequest);
        
        return ResponseEntity.ok(ApiResponse.success("Return request cancelled successfully", updatedRequest));
        
    } catch (NoSuchElementException e) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(ApiResponse.error(e.getMessage()));
    } catch (Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ApiResponse.error("Failed to cancel return request: " + e.getMessage()));
    }
}

@Operation(
    summary = "Track return request status",
    description = "Get current status and timeline of a return request"
)
@GetMapping("/{id}/track")
public ResponseEntity<ApiResponse<Map<String, Object>>> trackReturnStatus(
        @Parameter(description = "ID of the return request") @PathVariable Long id,
        @AuthenticationPrincipal UserDetails userDetails) {
    try {
        if (userDetails == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body(ApiResponse.error("User not authenticated."));
        }
        
        ReturnRequest returnRequest = returnRequestRepository.findById(id)
            .orElseThrow(() -> new NoSuchElementException("Return request not found with ID: " + id));
        
        User currentUser = userRepository.findByEmail(userDetails.getUsername())
            .orElseThrow(() -> new RuntimeException("Authenticated user not found."));
        
        // Security check
        if (!returnRequest.getUser().getId().equals(currentUser.getId())) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                .body(ApiResponse.error("Access denied. This return request does not belong to you."));
        }
        
        Map<String, Object> trackingInfo = new HashMap<>();
        trackingInfo.put("requestId", returnRequest.getId());
        trackingInfo.put("status", returnRequest.getStatus());
        trackingInfo.put("requestDate", returnRequest.getRequestDate());
        trackingInfo.put("resolutionDate", returnRequest.getResolutionDate());
        trackingInfo.put("estimatedTimeline", "3-5 business days for processing");
        
        if (returnRequest.getStatus() == ReturnRequest.ReturnStatus.APPROVED) {
            trackingInfo.put("nextSteps", "Refund will be processed within 24 hours");
        } else if (returnRequest.getStatus() == ReturnRequest.ReturnStatus.PENDING) {
            trackingInfo.put("nextSteps", "Under review by our team");
        }
        
        return ResponseEntity.ok(ApiResponse.success("Return status tracked successfully", trackingInfo));
        
    } catch (NoSuchElementException e) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(ApiResponse.error(e.getMessage()));
    } catch (Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ApiResponse.error("Failed to track return status: " + e.getMessage()));
    }
}
}

--- File: src/main/java/com/ecommerce/returnmanager/controller/AdminReturnController.java ---

package com.ecommerce.returnmanager.controller;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.ecommerce.returnmanager.dto.ApiResponse;
import com.ecommerce.returnmanager.model.ReturnRequest;
import com.ecommerce.returnmanager.repository.ReturnRequestRepository;
import com.ecommerce.returnmanager.service.ReturnRequestService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/api/v1/admin/returns")
@Tag(name = "Admin Return Management", description = "APIs for administrators to manage return requests")
public class AdminReturnController {

    private final ReturnRequestService returnRequestService;
    private final ReturnRequestRepository returnRequestRepository;

    public AdminReturnController(ReturnRequestService returnRequestService, ReturnRequestRepository rrr) {
        this.returnRequestService = returnRequestService;
        this.returnRequestRepository = rrr;
    }

    @Operation(
        summary = "Get all pending return requests",
        description = "Retrieve all return requests that are pending admin review"
    )
    @io.swagger.v3.oas.annotations.responses.ApiResponses({
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "200", description = "Pending requests retrieved successfully"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "401", description = "Unauthorized"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "403", description = "Forbidden - requires ADMIN role")
    })
    @GetMapping("/pending")
    public ResponseEntity<ApiResponse<List<ReturnRequest>>> getAllPendingReturns(
            @AuthenticationPrincipal UserDetails userDetails) {
        
        // Log admin activity (optional - for future auditing)
        if (userDetails != null) {
            System.out.println("Admin " + userDetails.getUsername() + " viewed pending returns");
        }
        
        List<ReturnRequest> requests = returnRequestService.getAllPendingRequests();
        return ResponseEntity.ok(ApiResponse.success("Pending return requests retrieved successfully", requests));
    }
    
    @Operation(
        summary = "Approve a return request",
        description = "Approve a pending return request and process refund"
    )
    @io.swagger.v3.oas.annotations.responses.ApiResponses({
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "200", description = "Return request approved successfully"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "401", description = "Unauthorized"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "403", description = "Forbidden - requires ADMIN role"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "404", description = "Return request not found"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "409", description = "Conflict - request not in pending status")
    })
    @PutMapping("/{id}/approve")
    public ResponseEntity<ApiResponse<ReturnRequest>> approveReturn(
            @Parameter(description = "ID of the return request to approve") @PathVariable Long id, 
            @Parameter(description = "Admin notes for the approval") @RequestParam String notes,
            @AuthenticationPrincipal UserDetails userDetails) {
        try {
            ReturnRequest updatedRequest = returnRequestService.approveRequest(id, notes);
            
            // Log admin activity
            if (userDetails != null) {
                System.out.println("Admin " + userDetails.getUsername() + " approved return request ID: " + id);
            }
            
            return ResponseEntity.ok(ApiResponse.success("Return request approved and refund processed", updatedRequest));
        } catch (NoSuchElementException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(ApiResponse.error("Return request not found with ID: " + id));
        } catch (IllegalStateException e) {
            return ResponseEntity.status(HttpStatus.CONFLICT)
                .body(ApiResponse.error("Cannot approve request: " + e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("Failed to approve request: " + e.getMessage()));
        }
    }

    @Operation(
        summary = "Reject a return request",
        description = "Reject a pending return request"
    )
    @io.swagger.v3.oas.annotations.responses.ApiResponses({
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "200", description = "Return request rejected successfully"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "401", description = "Unauthorized"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "403", description = "Forbidden - requires ADMIN role"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "404", description = "Return request not found"),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = "409", description = "Conflict - request not in pending status")
    })
    @PutMapping("/{id}/reject")
    public ResponseEntity<ApiResponse<ReturnRequest>> rejectReturn(
            @Parameter(description = "ID of the return request to reject") @PathVariable Long id, 
            @Parameter(description = "Reason for rejection") @RequestParam String notes,
            @AuthenticationPrincipal UserDetails userDetails) {
        try {
            ReturnRequest updatedRequest = returnRequestService.rejectRequest(id, notes);
            
            // Log admin activity
            if (userDetails != null) {
                System.out.println("Admin " + userDetails.getUsername() + " rejected return request ID: " + id);
            }
            
            return ResponseEntity.ok(ApiResponse.success("Return request rejected successfully", updatedRequest));
        } catch (NoSuchElementException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(ApiResponse.error("Return request not found with ID: " + id));
        } catch (IllegalStateException e) {
            return ResponseEntity.status(HttpStatus.CONFLICT)
                .body(ApiResponse.error("Cannot reject request: " + e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("Failed to reject request: " + e.getMessage()));
        }
    }

    @Operation(
    summary = "Get all return requests with filtering",
    description = "Retrieve all return requests with optional status filtering"
)
@GetMapping
public ResponseEntity<ApiResponse<List<ReturnRequest>>> getAllReturns(
        @Parameter(description = "Filter by status") @RequestParam(required = false) ReturnRequest.ReturnStatus status,
        @AuthenticationPrincipal UserDetails userDetails) {
    
    List<ReturnRequest> requests;
    if (status != null) {
        requests = returnRequestRepository.findAll().stream()
                .filter(r -> r.getStatus() == status)
                .collect(Collectors.toList());
    } else {
        requests = returnRequestRepository.findAll();
    }
    
    return ResponseEntity.ok(ApiResponse.success("Return requests retrieved successfully", requests));
}

@Operation(
    summary = "Get return statistics",
    description = "Retrieve statistics about return requests for admin dashboard"
)
@GetMapping("/statistics")
public ResponseEntity<ApiResponse<Map<String, Object>>> getReturnStatistics(
        @AuthenticationPrincipal UserDetails userDetails) {
    
    List<ReturnRequest> allRequests = returnRequestRepository.findAll();
    
    Map<String, Object> statistics = new HashMap<>();
    
    // Count by status
    statistics.put("total", allRequests.size());
    statistics.put("pending", allRequests.stream()
            .filter(r -> r.getStatus() == ReturnRequest.ReturnStatus.PENDING).count());
    statistics.put("approved", allRequests.stream()
            .filter(r -> r.getStatus() == ReturnRequest.ReturnStatus.APPROVED).count());
    statistics.put("rejected", allRequests.stream()
            .filter(r -> r.getStatus() == ReturnRequest.ReturnStatus.REJECTED).count());
    statistics.put("refunded", allRequests.stream()
            .filter(r -> r.getStatus() == ReturnRequest.ReturnStatus.REFUNDED).count());
    
    // Total refund amount
    BigDecimal totalRefundAmount = allRequests.stream()
            .filter(r -> r.getRefundAmount() != null)
            .map(ReturnRequest::getRefundAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    statistics.put("totalRefundAmount", totalRefundAmount);
    
    // Recent activity (last 7 days)
    long recentRequests = allRequests.stream()
            .filter(r -> r.getRequestDate().isAfter(LocalDateTime.now().minusDays(7)))
            .count();
    statistics.put("recentRequests", recentRequests);
    
    return ResponseEntity.ok(ApiResponse.success("Statistics retrieved successfully", statistics));
}
}

--- File: src/main/java/com/ecommerce/returnmanager/controller/LoginController.java ---

package com.ecommerce.returnmanager.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class LoginController {

    @GetMapping("/login")
    public String showLoginPage() {
        return "login";
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/model/Order.java ---

package com.ecommerce.returnmanager.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull(message = "Order date is required")
    private LocalDateTime orderDate;

    @Enumerated(EnumType.STRING)
    private OrderStatus status; // E.g., PENDING, SHIPPED, DELIVERED

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    @NotNull(message = "User must be associated with the order")
    private User user;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderItem> items;
    
    // Total amount can be calculated in the service layer, but stored for reporting
    @NotNull
    private Double totalAmount;

    public enum OrderStatus {
        PENDING, SHIPPED, DELIVERED, CANCELED
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/model/OrderItem.java ---

package com.ecommerce.returnmanager.model;

import java.math.BigDecimal;
import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "order_items")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Product name is required")
    private String productName;

    @Min(value = 1, message = "Quantity must be at least 1")
    private int quantity;

    @NotNull(message = "Price per item is required")
    private BigDecimal pricePerItem;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    // Relationship to ReturnRequest: One OrderItem can be linked to multiple ReturnRequests 
    // (if a customer returns items in batches, or if we track partial returns)
    // For simplicity, we'll assume one OrderItem can have ONE return request initiated against it at a time.
    @OneToMany(mappedBy = "orderItem", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ReturnRequest> returnRequests;

    // Note: The product ID (SKU) should be here in a real system.
}

--- File: src/main/java/com/ecommerce/returnmanager/model/User.java ---

package com.ecommerce.returnmanager.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Name is required")
    private String name;

    @Email(message = "Email should be valid")
    @NotBlank(message = "Email is required")
    @Column(unique = true)
    private String email;

    @NotBlank(message = "Password is required")
    private String password; // This will now be encrypted

    @Enumerated(EnumType.STRING)
    private Role role; // CUSTOMER or ADMIN

    public enum Role {
        CUSTOMER, ADMIN
    }

    // Add this method to get role with ROLE_ prefix for Spring Security
    public String getSpringSecurityRole() {
        return "ROLE_" + this.role.name();
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/model/ReturnRequest.java ---

package com.ecommerce.returnmanager.model;

import java.math.BigDecimal;
import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "return_requests")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ReturnRequest {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // 🔴 FIX 1: ADD THE MISSING order_id FIELD 🔴
    @Column(name = "order_id", nullable = false)
    private Long orderId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_item_id", nullable = false)
    @NotNull(message = "Return request must specify an order item")
    @JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
    private OrderItem orderItem;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    @NotNull(message = "Return request must be linked to a user")
    @JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
    private User user;

    // ✅ Updated validation for quantityReturned
    @NotNull(message = "Quantity to return is required")
    @Positive(message = "Quantity must be positive")
    private Integer quantityReturned;

    @Column(nullable = false)
    private LocalDateTime requestDate = LocalDateTime.now();

    private LocalDateTime resolutionDate; // When the request is approved/rejected

    @Enumerated(EnumType.STRING)
    private ReturnReason reason;

    @Enumerated(EnumType.STRING)
    private ReturnStatus status = ReturnStatus.PENDING;

    // Calculated fields
    private BigDecimal refundAmount;
    private String adminNotes;

    public enum ReturnReason {
        DAMAGED, WRONG_ITEM, DONT_WANT, TOO_LATE, OTHER
    }

    public enum ReturnStatus {
        PENDING, APPROVED, REJECTED, REFUNDED, CLOSED
    }
}


--- File: src/main/java/com/ecommerce/returnmanager/service/ReturnRequestService.java ---

package com.ecommerce.returnmanager.service;

import java.util.List;
import java.util.Optional;

import com.ecommerce.returnmanager.model.ReturnRequest;

public interface ReturnRequestService {

    /**
     * Initiates a new return request by a customer.
     * Includes business logic validation (e.g., 30-day window check).
     * @param request The ReturnRequest object populated with order and user data.
     * @return The saved ReturnRequest.
     */
    ReturnRequest initiateReturn(ReturnRequest request);

    /**
     * Retrieves all pending return requests for an admin review.
     * @return List of ReturnRequest objects.
     */
    List<ReturnRequest> getAllPendingRequests();

    /**
     * Approves a pending return request.
     * Updates status to APPROVED and handles refund calculation (simulated).
     * @param requestId ID of the request to approve.
     * @param adminNotes Notes from the admin processing the request.
     * @return The updated ReturnRequest.
     */
    ReturnRequest approveRequest(Long requestId, String adminNotes);

    /**
     * Rejects a pending return request.
     * Updates status to REJECTED.
     * @param requestId ID of the request to reject.
     * @param adminNotes Notes explaining the rejection reason.
     * @return The updated ReturnRequest.
     */
    ReturnRequest rejectRequest(Long requestId, String adminNotes);

    /**
     * Retrieves a single return request by ID.
     * @param id The ID of the request.
     * @return An Optional containing the request or empty if not found.
     */
    Optional<ReturnRequest> getRequestById(Long id);
}

--- File: src/main/java/com/ecommerce/returnmanager/service/EmailService.java ---

package com.ecommerce.returnmanager.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class EmailService {
    
    private static final Logger logger = LoggerFactory.getLogger(EmailService.class);

    public void sendReturnConfirmation(String customerEmail, Long requestId) {
        // In production, integrate with actual email service (SendGrid, AWS SES, etc.)
        String subject = "Return Request Confirmation - #" + requestId;
        String body = String.format("""
            Dear Customer,
            
            Your return request #%d has been received and is under review.
            
            We will process your request within 3-5 business days.
            
            Thank you,
            E-commerce Return Team
            """, requestId);
            
        logger.info("EMAIL_SENT | To: {} | Subject: {} | Body: {}", 
                   customerEmail, subject, body);
        
        // Simulate email sending
        System.out.println("=== EMAIL NOTIFICATION ===");
        System.out.println("To: " + customerEmail);
        System.out.println("Subject: " + subject);
        System.out.println("Body: " + body);
        System.out.println("=========================");
    }

    public void sendReturnApproval(String customerEmail, Long requestId, Double refundAmount) {
        String subject = "Return Approved - Refund Processed #" + requestId;
        String body = String.format("""
            Dear Customer,
            
            Great news! Your return request #%d has been approved.
            
            A refund of $%.2f has been processed and will reflect in your account within 5-7 business days.
            
            Thank you for shopping with us!
            
            Sincerely,
            E-commerce Return Team
            """, requestId, refundAmount);
            
        logger.info("APPROVAL_EMAIL_SENT | To: {} | RequestID: {} | Refund: ${}", 
                   customerEmail, requestId, refundAmount);
        
        System.out.println("=== REFUND APPROVAL EMAIL ===");
        System.out.println("To: " + customerEmail);
        System.out.println("Subject: " + subject);
        System.out.println("Refund Amount: $" + refundAmount);
        System.out.println("=============================");
    }

    public void sendAdminAlert(String subject, String message) {
        logger.info("ADMIN_ALERT | Subject: {} | Message: {}", subject, message);
        
        System.out.println("=== ADMIN ALERT ===");
        System.out.println("Subject: " + subject);
        System.out.println("Message: " + message);
        System.out.println("===================");
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/service/impl/ReturnRequestServiceImpl.java ---

package com.ecommerce.returnmanager.service.impl;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.ecommerce.returnmanager.config.AuditLogger;
import com.ecommerce.returnmanager.model.Order;
import com.ecommerce.returnmanager.model.OrderItem;
import com.ecommerce.returnmanager.model.ReturnRequest;
import com.ecommerce.returnmanager.model.ReturnRequest.ReturnStatus;
import com.ecommerce.returnmanager.repository.OrderItemRepository;
import com.ecommerce.returnmanager.repository.ReturnRequestRepository;
import com.ecommerce.returnmanager.service.EmailService;
import com.ecommerce.returnmanager.service.ReturnRequestService;


@Service
public class ReturnRequestServiceImpl implements ReturnRequestService {

    private final ReturnRequestRepository returnRequestRepository;
    private final OrderItemRepository orderItemRepository;
    private final AuditLogger auditLogger;
    private final EmailService emailService;

    public ReturnRequestServiceImpl(ReturnRequestRepository returnRequestRepository, 
                                   OrderItemRepository orderItemRepository,
                                   AuditLogger auditLogger,
                                   EmailService emailService) {
        this.returnRequestRepository = returnRequestRepository;
        this.orderItemRepository = orderItemRepository;
        this.auditLogger = auditLogger;
        this.emailService = emailService;
    }

    private static final int RETURN_WINDOW_DAYS = 30;

    @Override
    @Transactional
    public ReturnRequest initiateReturn(ReturnRequest request) {
        long startTime = System.currentTimeMillis();
        
        try {
            // 1. Validate Order Item Existence and link to Order
            Long orderItemId = request.getOrderItem().getId();
            OrderItem item = orderItemRepository.findById(orderItemId)
                    .orElseThrow(() -> new NoSuchElementException("Order Item not found with ID: " + orderItemId));
            
            Order order = item.getOrder();

            // Set the order ID
            request.setOrderId(order.getId()); 

            // 2. Business Logic: Check 30-day return window
            long daysSinceOrder = ChronoUnit.DAYS.between(order.getOrderDate(), LocalDateTime.now());
            if (daysSinceOrder > RETURN_WINDOW_DAYS) {
                request.setStatus(ReturnStatus.REJECTED);
                request.setAdminNotes("Request automatically rejected: Exceeded the " + RETURN_WINDOW_DAYS + "-day return window.");
                
                ReturnRequest rejectedRequest = returnRequestRepository.save(request);
                
                // Log automatic rejection
                auditLogger.logReturnRejection(
                    rejectedRequest.getId(), 
                    "system",
                    "Automatic rejection: Exceeded " + RETURN_WINDOW_DAYS + "-day return window"
                );
                
                return rejectedRequest;
            }
            
            // 3. Calculate Refund Amount (price per item * quantity returned)
            BigDecimal itemPrice = item.getPricePerItem();
            BigDecimal quantity = BigDecimal.valueOf(request.getQuantityReturned());
            BigDecimal refundAmount = itemPrice.multiply(quantity);
            
            // 4. Set Initial Status and Amounts
            request.setOrderItem(item);
            request.setRefundAmount(refundAmount);
            request.setStatus(ReturnStatus.PENDING);
            request.setRequestDate(LocalDateTime.now());

            ReturnRequest savedRequest = returnRequestRepository.save(request);
            
            // Log the action
            auditLogger.logReturnCreation(
                savedRequest.getId(), 
                request.getUser().getEmail(),
                request.getOrderItem().getProductName()
            );
            
            // Send confirmation email
            emailService.sendReturnConfirmation(
                request.getUser().getEmail(), 
                savedRequest.getId()
            );
            
            // Log performance
            long duration = System.currentTimeMillis() - startTime;
            auditLogger.logPerformance("initiateReturn", duration);
            
            return savedRequest;
            
        } catch (Exception e) {
            auditLogger.logError("initiateReturn", e.getMessage(), 
                               request.getUser() != null ? request.getUser().getEmail() : "unknown");
            throw e;
        }
    }

    @Override
    public List<ReturnRequest> getAllPendingRequests() {
        long startTime = System.currentTimeMillis();
        
        try {
            List<ReturnRequest> requests = returnRequestRepository.findAll().stream()
                    .filter(r -> r.getStatus() == ReturnStatus.PENDING)
                    .collect(Collectors.toList());
            
            // Log performance
            long duration = System.currentTimeMillis() - startTime;
            auditLogger.logPerformance("getAllPendingRequests", duration);
            
            return requests;
        } catch (Exception e) {
            auditLogger.logError("getAllPendingRequests", e.getMessage(), "system");
            throw e;
        }
    }

    @Override
    @Transactional
    public ReturnRequest approveRequest(Long requestId, String adminNotes) {
        long startTime = System.currentTimeMillis();
        
        try {
            ReturnRequest request = returnRequestRepository.findById(requestId)
                    .orElseThrow(() -> new NoSuchElementException("Return Request not found with ID: " + requestId));

            if (request.getStatus() != ReturnStatus.PENDING) {
                throw new IllegalStateException("Cannot approve a request that is not PENDING. Current status: " + request.getStatus());
            }

            request.setStatus(ReturnStatus.APPROVED);
            request.setResolutionDate(LocalDateTime.now());
            request.setAdminNotes(adminNotes);
            
            // In a real system, a refund process would be triggered here. 
            // For now, we simulate success and set status to REFUNDED immediately.
            request.setStatus(ReturnStatus.REFUNDED); 
            
            ReturnRequest updatedRequest = returnRequestRepository.save(request);
            
            // Log approval
            auditLogger.logReturnApproval(
                requestId, 
                "admin", // In real app, get from security context
                request.getRefundAmount().doubleValue()
            );
            
            // Send approval email to customer
            emailService.sendReturnApproval(
                request.getUser().getEmail(),
                requestId,
                request.getRefundAmount().doubleValue()
            );
            
            // Send admin alert for high-value refunds
            if (request.getRefundAmount().compareTo(new BigDecimal("500.00")) > 0) {
                emailService.sendAdminAlert(
                    "High-Value Refund Processed",
                    String.format("Refund of $%.2f processed for return request #%d", 
                                request.getRefundAmount().doubleValue(), requestId)
                );
            }
            
            // Log performance
            long duration = System.currentTimeMillis() - startTime;
            auditLogger.logPerformance("approveRequest", duration);
            
            return updatedRequest;
            
        } catch (Exception e) {
            auditLogger.logError("approveRequest", e.getMessage(), "admin");
            throw e;
        }
    }

    @Override
    @Transactional
    public ReturnRequest rejectRequest(Long requestId, String adminNotes) {
        long startTime = System.currentTimeMillis();
        
        try {
            ReturnRequest request = returnRequestRepository.findById(requestId)
                    .orElseThrow(() -> new NoSuchElementException("Return Request not found with ID: " + requestId));

            if (request.getStatus() != ReturnStatus.PENDING) {
                throw new IllegalStateException("Cannot reject a request that is not PENDING. Current status: " + request.getStatus());
            }
            
            request.setStatus(ReturnStatus.REJECTED);
            request.setResolutionDate(LocalDateTime.now());
            request.setAdminNotes(adminNotes);

            ReturnRequest updatedRequest = returnRequestRepository.save(request);
            
            // Log rejection
            auditLogger.logReturnRejection(
                requestId, 
                "admin",
                adminNotes
            );
            
            // Log performance
            long duration = System.currentTimeMillis() - startTime;
            auditLogger.logPerformance("rejectRequest", duration);
            
            return updatedRequest;
            
        } catch (Exception e) {
            auditLogger.logError("rejectRequest", e.getMessage(), "admin");
            throw e;
        }
    }

    @Override
    public Optional<ReturnRequest> getRequestById(Long id) {
        long startTime = System.currentTimeMillis();
        
        try {
            Optional<ReturnRequest> request = returnRequestRepository.findById(id);
            
            // Log performance
            long duration = System.currentTimeMillis() - startTime;
            auditLogger.logPerformance("getRequestById", duration);
            
            return request;
        } catch (Exception e) {
            auditLogger.logError("getRequestById", e.getMessage(), "system");
            throw e;
        }
    }

    // Additional method for analytics
    public BigDecimal getTotalRefundsProcessed() {
        return returnRequestRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReturnStatus.REFUNDED && r.getRefundAmount() != null)
                .map(ReturnRequest::getRefundAmount)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    // Additional method for dashboard statistics
    public long getReturnCountByStatus(ReturnStatus status) {
        return returnRequestRepository.findAll().stream()
                .filter(r -> r.getStatus() == status)
                .count();
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/service/impl/UserDetailsServiceImpl.java ---

package com.ecommerce.returnmanager.service.impl;

import java.util.Collections;

import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import com.ecommerce.returnmanager.repository.UserRepository;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;

    public UserDetailsServiceImpl(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        com.ecommerce.returnmanager.model.User appUser = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + email));

        // Convert our Role enum to Spring Security role format
        String role = "ROLE_" + appUser.getRole().name();
        
        return new User(
                appUser.getEmail(),
                appUser.getPassword(),
                Collections.singletonList(new SimpleGrantedAuthority(role))
        );
    }
}

--- File: src/main/java/com/ecommerce/returnmanager/exception/GlobalExceptionHandler.java ---

package com.ecommerce.returnmanager.exception;

import java.time.LocalDateTime;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

import com.ecommerce.returnmanager.dto.ErrorResponse;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NoSuchElementException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(NoSuchElementException ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
            LocalDateTime.now(),
            HttpStatus.NOT_FOUND.value(),
            "Resource Not Found",
            ex.getMessage(),
            request.getDescription(false),
            null
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<ErrorResponse> handleIllegalState(IllegalStateException ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
            LocalDateTime.now(),
            HttpStatus.CONFLICT.value(),
            "Business Rule Violation",
            ex.getMessage(),
            request.getDescription(false),
            null
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.CONFLICT);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgument(IllegalArgumentException ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
            LocalDateTime.now(),
            HttpStatus.BAD_REQUEST.value(),
            "Invalid Argument",
            ex.getMessage(),
            request.getDescription(false),
            null
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDenied(AccessDeniedException ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
            LocalDateTime.now(),
            HttpStatus.FORBIDDEN.value(),
            "Access Denied",
            "You don't have permission to access this resource",
            request.getDescription(false),
            null
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex, WebRequest request) {
        List<ErrorResponse.FieldError> fieldErrors = ex.getBindingResult()
            .getAllErrors()
            .stream()
            .map(error -> {
                String fieldName = ((FieldError) error).getField();
                String errorMessage = error.getDefaultMessage();
                Object rejectedValue = ((FieldError) error).getRejectedValue();
                return new ErrorResponse.FieldError(fieldName, errorMessage, rejectedValue);
            })
            .collect(Collectors.toList());

        ErrorResponse errorResponse = new ErrorResponse(
            LocalDateTime.now(),
            HttpStatus.BAD_REQUEST.value(),
            "Validation Failed",
            "Request validation failed",
            request.getDescription(false),
            fieldErrors
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex, WebRequest request) {
        ErrorResponse errorResponse = new ErrorResponse(
            LocalDateTime.now(),
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            "Internal Server Error",
            "An unexpected error occurred",
            request.getDescription(false),
            null
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

